# 2.1 Code review GO:
``` go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "github.com/go-sql-driver/mysql"
)

var db *sql.DB
var err error

func initDB() {
    db, err = sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        log.Fatal(err)
    }

err = db.Ping()
if err != nil {
    log.Fatal(err)
    }
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }

searchQuery := r.URL.Query().Get("query")
if searchQuery == "" {
    http.Error(w, "Query parameter is missing", http.StatusBadRequest)
    return
}

query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
if err != nil {
    http.Error(w, "Query failed", http.StatusInternalServerError)
    log.Println(err)
    return
}
defer rows.Close()

var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}

fmt.Fprintf(w, "Found products: %v\n", products)
}

func main() {
    initDB()
    defer db.Close()

http.HandleFunc("/search", searchHandler)
fmt.Println("Server is running")
log.Fatal(http.ListenAndServe(":8080", nil))
}
```
### Уязвимости и Их Последствия
1.	SQL-инъекция:
   
  • Строка: query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
  
  • Последствия: Злоумышленник может инжектировать произвольный SQL-код, что может привести к несанкционированному доступу к данным, удалению или модификации данных в базе.
  
2. 	Отсутствие валидации входных данных:
   
  •	Строка: searchQuery := r.URL.Query().Get("query")
  
  •	Последствия: Помимо SQL-инъекций, отсутствие проверки входных данных может привести к другим видам атак, например, к перенаправлению на вредоносные сайты через подмену параметров запроса.
  
3.  Недостаточное управление ресурсами:
   
  •	Строка: Весь фрагмент кода.
  •	Последствия: Использование log.Fatal внутри обработчиков запросов приведет к остановке всего сервера при возникновении ошибки, что может быть использовано для DoS-атак.

### Исправления Уязвимостей
1.	Исправление SQL-инъекции:

  •	Используйте параметризованные запросы или подготовленные выражения (prepared statements), которые предотвращают интерпретацию ввода пользователя как части SQL-команды.
  
  •	Пример:
  goCopy code
  query := "SELECT * FROM products WHERE name LIKE ?" rows, err := db.Query(query, "%"+searchQuery+"%") 
  
2.	Валидация входных данных:

  •	Добавьте проверку входных данных на предмет соответствия ожидаемому формату или диапазону значений перед их использованием в запросах или другой бизнес-логике.
  
3.	Улучшение управления ресурсами:

  •	Замените log.Fatal на log.Print или другие менее радикальные способы обработки ошибок, чтобы предотвратить остановку всего приложения при обнаружении ошибки. Используйте подходы, позволяющие приложению продолжать работу и корректно обрабатывать ошибки 


###Лучший Способ Исправления

Для SQL-инъекции, лучшим решением будет использование параметризованных запросов. Это наиболее прямой и эффективный способ предотвратить инъекцию, так как он гарантирует, что переданные данные будут обработаны как параметры, а не как часть SQL-кода. Это решение также упрощает код и повышает его читаемость, делая его более безопасным и устойчивым к будущим изменениям.


# 2.2 Code Review: Python
Пример 2.1  
```python
from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
    return output

if __name__ == "__main__":
    app.run(debug=True)
```

Разбор:
### Уязвимость:

•	В строке, где создается Template, есть потенциальная уязвимость для инъекций шаблонов Jinja2: output = Template('Hello ' + name + '! Your age is ' + age + '.').render()

### Последствие:

•	Злоумышленник может выполнить произвольный код на сервере путем инъекции вредоносных шаблонов Jinja2, что может привести к несанкционированному доступу, раскрытию конфиденциальной информации, удалению данных и т.д.

### Способ исправления:

•	Использование контекстных переменных при рендеринге шаблонов. Это предпочтительно, так как экранирование может не всегда надежно предотвратить все виды инъекций, а использование контекстных переменных предоставляет более надежный механизм безопасности за счет правильного управления пользовательским вводом.


### Возможный код исправления с контекстными переменным:

```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    # Использование безопасного способа передачи переменных в шаблон
    template_str = 'Hello {{ name }}! Your age is {{ age }}.'
    output = render_template_string(template_str, name=name, age=age)
    return output

if __name__ == "__main__":
    app.run(debug=True)
```


Пример 2.2 
```python
from flask import Flask, request
import subprocess

app = Flask(__name__)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
    return output

if __name__ == "__main__":
    app.run(debug=True)
```
### Уязвимости:

•	В строке, где формируется команда для выполнения: cmd = 'nslookup ' + hostname

•	И в строке, где выполняется команда: output = subprocess.check_output(cmd, shell=True, text=True)

### Последствия:

•	Это пример уязвимости внедрения команд, который позволяет злоумышленнику исполнять произвольные команды на сервере. Это может привести к несанкционированному доступу, удалению данных, установке вредоносного ПО и т.д.

### Исправление:

•	Использование списков для передачи команды и аргументов. Этот метод исключает возможность интерпретации оболочкой произвольных аргументов как части команды, тем самым предотвращая внедрение команд. Санитизация может быть обходным путем для определенных векторов атаки, но использование списков является более надежным подходом.

### Исправленный код:
```python
from flask import Flask, request
import subprocess

app = Flask(__name__)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    # Формирование команды с использованием списка для безопасного выполнения
    cmd = ['nslookup', hostname]
    try:
        output = subprocess.check_output(cmd, text=True)
    except subprocess.CalledProcessError as e:
        output = str(e)
    return output

if __name__ == "__main__":
    app.run(debug=True)
```


# 3. Моделирование угроз

![image](https://github.com/Kimlot01/test-assignment-answer-/assets/131708003/3cba156f-699c-44d6-90f9-f71042aaa0a3)


 

### Потенциальные Проблемы Безопасности:

1.	Нешифрованный трафик
•	Если взаимодействие между слоями не использует шифрование (TLS/SSL), данные могут быть перехвачены или изменены.
2.	Аутентификация и Авторизация
•	Уязвимости в сервисе Auth могут позволить неавторизованный доступ к системе.
3.	Взаимодействие с внешними сервисами
•	Slack и Telegram могут быть скомпрометированы, что ставит под угрозу целостность системы.
4.	Хранение данных в S3 и PostgreSQL
•	Неправильно настроенное хранилище S3 может позволить несанкционированный доступ к статическому контенту.
•	Уязвимости в базе данных PostgreSQL могут привести к утечке или потере конфиденциальной информации.

### Последствия Эксплуатации Уязвимостей:

•	Перехват Данных: Злоумышленник может читать или изменять данные в передаче.

•	Неавторизованный Доступ: Доступ к конфигурациям, персональным данным пользователей или статическому контенту.

•	Сервисные Атаки: DoS-атаки могут сделать сервис недоступным.

•	Компрометация Системы: Возможное исполнение кода или другие атаки на компоненты системы.

### Способы Исправления и Смягчения Рисков:

1.	Использование TLS/SSL:
•	Внедрение протокола TLS для шифрования трафика между компонентами системы.
2.	Многофакторная аутентификация и сильные политики паролей:
•	Включение MFA и обязательное использование сильных паролей для улучшения безопасности.
3.	Обеспечение безопасности интеграций:
•	Использование безопасных методов аутентификации и авторизации для интеграции с внешними сервисами, такими как Slack и Telegram.
4.	Надёжная конфигурация S3 и PostgreSQL:
•	Применение политик доступа, шифрование данных на стороне S3 и PostgreSQL для защиты данных в покое.
5.	Регулярное обновление и патчинг:
•	Обеспечение своевременного обновления всех компонентов системы и применение последних патчей безопасности.

### Уточняющие Вопросы Разработчикам:

1.	Какие протоколы шифрования используются для защиты данных в передаче?
2.	Как реализованы процессы аутентификации и авторизации пользователей?
3.	Какие меры безопасности используются для взаимодействия с внешними сервисами?
4.	Какие политики доступа настроены для хранилища S3?
5.	Как происходит обновление и патчинг компонентов системы?
6.	Существуют ли политики резервного копирования и восстановления для базы данных?
7.	Какие методы логирования и мониторинга используются для обнаружения опасностей системы 
